-생성할 떄!!!!!
ctrl+n 해서 그냥 생성하려는거 키워드 입력해서 찾아가지고 생성하기 


# 참조 자료형
 1. 기본 자료형
 2. 참조 자료형: class, String, Date(같은 자바 라이브러리)
 	클래스가 자료형이 되는 것
 	
 DB와도 관련 있음!!
 
 학생의 속성 중 수업에서
 수업에 대한 각 속성을 학생 클래스에 정의하는 게 아니라
 수업이라는 새 클래스로 분리한다
 
 학생: 학번, 학생 이름, 국어 성적, 수학 성적, 수강과목 이름
 -이렇게 되면 과목 수가 늘어날 경우... 국어 성적, 수학 성적, 영어 성적, 영어 선생님... 등등
 학생 클래스가 지저분하고 복잡해짐 
 따라서 클래스를 분리해서! 
 
 -> 학생: 학번, 학생 이름, 과목_국어, 과목_수학
 	+과목: 과목 이름, 과목 점수 
 	
 	
# 정보 은닉

-OOP
-접근 제어자
	public: 다 갖다 쓸 수 있음
	private: 내 클래스 안에서만 
	아무것도 안 쓰는 경우: default. 같은 패키지 내에서는 access 가능 (visibility)
	protective: 상속의 경우. 다른 데서는 private, 상속 관계에서만 사용 가능
	


# this
-java, C++ 
-자신의 메모리를 가리킴=주소 (생성된 인스턴스 스스로를 가리키는 예약어)

	public Person(String name, int age) {
	
		this.name = name;
		this.age = age;
	
	}
	
	위 코드에서 this를 생략하게 되면 name=name; age=age;가 되는데,
	이렇게 되면 매개변수(parameter)로 사용되는 name과 age로 인식됨 
	따라서 멤버변수를 가리키려면 this를 붙여야 함 


-생성자에서 다른 생성자 호출
	생성자: 객체가 생성될 때 초기화. 해야 하는 작업. 주로 멤버변수 세팅.
	생성자는 1개 이상일 수 있음 (생성자 오버로딩)
	
	public Person() {
	
		this("이름 없음", 1); //  이 부분이 바로 밑에 있는 다른 생성자를 호출하는 부분 

	}
	
	public Person(String name, int age) {
	
		this.name = name;
		this.age = age;
	
	}



-자신의 주소 반환
: 이거는 잘 쓰지는 않음. 1, 2는 많이 씀. 



# 객체 간의 협력
-객체간의 협력을 이용해서 프로그래밍이 구현
-학생이 버스나 지하철을 가는 상황을 객체지향으로 프로그래밍

class 3개
학생: 이름, 학년, 가진 돈 + 버스를 탄다, 지하철을 탄다 
버스: 버스 번호, 승객 수, 수입
지하철: 노선 번호, 승객 수, 수입	

학생이 버스를 탄다 -> 어떤 일이 일어나는지?
돈을 내고 -> 이 돈이 학생에서는 -, 버스에서는 +, 승객수 +1

지하철 탄다
학생에게는 돈 -, 지하철 돈+1, 승객수 +1


+ 상속의 개념?
버스, 지하철 - 운송 수단: 승객을 태우고, 돈을 받고
따라서 상위 클래스로 운송수단을 하나 만들고 이걸로 버스, 지하철, 택시, 자전거가 상속하도록 
동일 메서드: take (상위 클래스에서 추상메서드로 두고, 학생이 trans와 협업할 수 있게끔)
운송 수단을 하나로 모아서 관리할 수 있는! (상속의 장점) 




# static 
static 변수의 정의와 사용 방법
인스턴스: 클래스에서 생성된 각각의 객체
Student Class -> new 로 생성 -> heap 메모리에 인스턴트 생성 james
int id 											int id
													thomas
												int id
그런데 하다 보면 인스턴스끼리 공유해야 되는 값이 있을 수 있음
지금 이렇게 각각 잡게 되면 james의 id와 thomas의 id는 다 다르다
그런데 모든 인스턴스들이 공유하는 값이 필요할 수 있음
이때 이런 변수를 static으로 선언한다 
즉, 여러 인스턴스가 같은 메모리의 값을 공유하기 위해 


heap: 동적 메모리
객체 생성 시 (new 할 때) 할당, 객체 소멸 시 사라짐 (free)

static 변수의 경우 인스턴스들이 공유하기 때문에 다른 메모리를 씀
data 영역=상수 영역=정적 영역에 생성
new 할 때 할당받는 게 X 
전체 프로그램이 메모리에 로드(적재)될 때 데이터 영역의 메모리에 생성 
인스턴트의 생성과 상관없이 클래스 이름으로 직접 참조
클래스 변수(멤버 변수=인스턴스 변수)
스태틱 변수를 사용할 때는 객체명.스태틱 변수 < 이런 식으로 직접 참조 변수로 사용하지 않고 
그냥 클래스이름.static 변수 < 이런 식으로 참조함 
static 변수는 인스턴스 생성과 관계없이 메모리에 잡힘



상수, 리터럴, static 변수 

static 변수는 인스턴스가 공유하는 변수다 

static 자료형 변수이름 



ex) 학생 생성할 때마다 학번 부여.
그런데 생성된 차례로 순차적으로 부여 (1씩 증가하면서) 
A: 10001 -> B:10002 
따라서 기준되는 숫자가 있어야 거기서 하나를 더해서 a에게, 그 다음에 1 더해서 B에게 
이런 변수를 static으로 선언 (singleton과 비슷한 개념) 

프로그램의 메모리: 데이터 영역, 	스택 메모리, 	힙 메모리
			static, 리터럴	지역변수
					   메서드 내의 변수


지역변수: 함수 끝나면 사라짐
인스턴스 변수: 힙메모리에 new, 자바는 GC가 스레드 돌면서 free해 줌 C/C++ 직접 해제해야 함
스태틱: 프로그램 로드될 떄, 프로그램이 끝날 때까지! 너무 큰 메모리 사용은 지양. 




## static 응용: singleton 패턴

-디자인 패턴: 객체 지향에서 어떻게 설계하면 좋은지 설명한 책 
중 하나

-프로그램을 할 때 클래스를 설계하고 클래스로부터 객체를 생성
-이 객체는 여러개면 안 되는 게 있을 때

C: global 변수  프로젝트 내에서 단 하나의 변수로
java: class 외부에는 어떤 것도 선언할 수 없음... (import 제외)
다른 클래스의 것을 참조하는 것만 가능. global처럼은 안 됨. 

자동차 회사 -> 여러 직원 -> 여러 공장 -> 생산(메서드), 된 자동차 운반하는 자동차
여기서 객체는 무엇이고, 자동차 회사 시스템 만들 때 단 하나여야만 하는 것?
자동차 회사 < 이건 오로지 하나만 있어야 함. 단 하나의 인스턴스. 여러 인스턴스일 수 없다.

날짜에서도 서울 동경 시간 단 하나. 
calendar라는 클래스에서 가져다쓸 떄 하나로 구성되어 있음. 

전 시스템에 단 하나의 인스턴스만이 존재하도록 구현하는 방식
-java는 글로벌 변수가 없다 -> static 변수 사용
-생성자가 없으면 public, default 생성자가 생성된다 -> 생성자를 private으로 만듦

외부에서 생성된 static으로 생성된 객체를 사용할 수 있어야 한다 -> public으로 선언된 static 메서드 제공



# 배열과 ArrayList

-배열: 동일한 자료가 연속적, 순차적으로 있는 자료 구조
-여러 개의 데이터가 동일한 자료형이고 한꺼번에 관리할 때, 그리고 순차적으로 메모리에 있을 때
논리적, 물리적으로 연속된 자료구조
length (fixed)
size (실제 값이 채워진 만큼의 길이)
index: 0부터 length-1 까지
a b c d e
b 생략(삭제) -> 지워진다고 해서 b가 있던 위치를 비워 두면 안 됨. c를 b 위치로 옮겨 줘야 됨
배열: 연속된 자료구조

꽉 찬 배열에 F를 넣고 싶어도 공간이 없기 때문에 새 배열을 더 길게 만들어서
a b c d e f 이렇게 넣어주어야 함 

동일한 자료형의 변수를 한거번에 순차적으로 관리할 수 있는 자료구조.

자료형[] 배열이름 = new 자료형[개수];
자료형 배열이름[] = new 자료형[개수];

int[] arr_list = new int[5];
int arr_list[] = new int[5];

-배열의 길이와 유효한 요소값
배열의 길이의 속성: length
자료가 있는 요소만 출력하려면 크기에 대한 저장을 따로 해야

-숫자, 실수, 문자 배열

# 객체 배열
-참조 자료형을 선언하는 객체 배열
-배열을 선언만 한 경우에는 null로 초기화됨
-각 요소를 new를 활용하여 생성하여 저장해야 함 

# 배열 복사
처음에 fixed length로 시작
처음 모자라거나 하면 더 큰 배열 만들어서 기존 배열값 복사해서 추가
혹은 똑같은 배열 그냥 복사

System.arraycopy(src, srcPos, dest, destPos, length);
복사할 배열, 복사할 첫 위치, 대상 배열, 붙여넣을 첫 위치, 복사할 요소 개수 
size 맞춰서 해야 함 


#객체 배열 복사
-얕은 복사(shallow copy)
system.arraycopy를 쓰게 되면 얕은 복사임. 주소만 복사됨.
그래서 원래 요소값이 바뀌면 -> 복사된 배열에도 같이 반영됨

-깊은 복사(deep copy)
그렇게 되지 않으려면 인스턴스를 새로 생성해서 값들만 복사해서 채워 줘야 한다 
이런 식으로...
bookArray2[i].setBookName(bookArray1[i].getBookName());

동일한 인스턴스를 가리켜도 되면 얕게,
아니라면 깊은복사


-향상된 포문 (enhanced for loop)
for 



# 다차원 배열 = 일차원 배열이 여러 개 있는것 
-차원이 여러 개 (2차원 이상)
-지도, 게임 등 평면이나 공간을 구현할 때 사용
-이차원 배열의 선언과 구조
-2행 3열 [2][3]

행을 먼저 하고, 열을 돌리고
그 다음 행 가서 열 돌리고 -> 이중 for문	

0.0 0.1 0.2
0.3 0.4 0.5

1 2 3
4 5 6


# ArrayList 클래스
-기존 배열: 길이를 정해서 선언, 사용 중 부족할 경우 복사해서 구현해야 함
-요소가 중간에 삭제되거나 삽입되는 경우 역시 코드 구현해야 함
-java에서 제공되는 객체 배열이 구현된 클래스
-여러 메서드나 속성을 사용해서 객체 배열 편하게 관리 가능!

메서드
E: 요소 자료형 
-bool add(E e): 요소 하나를 추가. 
-int size(): 배열에 추가된 요소 전체 개수 반환
-E get(int index): 배열의 index 위치에 있는 요소 반환
-E remove(int index): 배열의 index 위치에 있는 요소 값 제거 후 반환
-boolean isEmpty()

학생이 여러 과목을 듣는다.
학생과 과목을 분리해서 class로 관리. 과목의 모든 속성을 학생의 property? (x)



## 이클립스 디버깅!!!!!!
더블클릭 해서 중단점 설정 



	
	
	