# 상속과 다형성

상속: 이것을 사용하면 OOP에서 다형성을 구현할 수 있다
클래스를 정의할 때 이미 구현된 클래스를 상속(inheritance)받아서 속성이나 기능이 확장되는 클래스를 구현함

상속을 하는 클래스: 상위 클래스, parent class, base class, super class
상속을 받는 클래스: 하위 클래스, child class, derived class, subclass
subclassing : C++에서 사용하는 단어 

(하위) B -▷ A (상위)

상위클래스: 하위 클래스보다 일반적인 의미
상속이 곧 재사용은 아님. 
일반적인 것에서 좀 더 구체적인 것으로 갈 때.
(하위) 사람 -> 포유류 (상위)
포유류가 사람보다 훨씬 더 일반적인 개념. 
사람은 포유류지만 더 구체적인 기능이 있음: 직립보행, 문자 사용 등
포유류의 기능을 상속하면서 더 추가적인 기능을 가짐
상속은 항상 코드의 재사용이 아님.
코드의 재사용을 하긴 하지만 코드의 재사용 방법이 상속은 아니다.

코드의 재사용 방법: 1) 상속 2) 합성 (aggregation)
올바른 상속: 보편적(일반적)인 클래스가 있고, 그 기능을 가져다 쓰면서 좀 더 구체적인(add on) 기능의 클래스를 만들 떄 사용
is-A 관계

extends 사용 

고객관리 프로그램
고객의 등급에 따라 차별화된 할인율, 포인트, 혜택 지급 
일반적인 클래스를 먼저 구현하고 보다 기능이 많은 클래스는 상속을 활용하여 구현
VIP customer -> 고객
gold customer -> 고객

단골고객 관리를 위해 새 고객 등급이 필요함
단골고객에게 적용할 혜택 필요
-고객등급 VIP
-제품 할인율 10퍼
보넉스 포인트 5퍼
담당전문상담원 배정


# 접근 제한자 가시성
하위 클래스가 생성될 때는 상위 클래스가 먼저 생성됨
그래서 상위 클래스들의 멤버변수들이 메모리를 잡게 되고 
하위 클래스가 걔네들을 사용할 수 있다!

상속에서의 메모리 상태
private 변수도 생성이 되지만 볼 수는 없을 뿐 (접근할 수 없을 뿐) setter getter 말고 직접 접근해서 초기화가 안됨 
생성은 된다 


# 상위 클래스로의 형 변환
customer -> vipcustomer
모든 vipcustomer는 customer의 일종이지만
모든 customer는 vipcustomer는 아님!

묵시적 형 변환(upcasting)
Customer vc = new VIPCustomer();
상속받은 클래스는 상위 클래스의 타입을 내포하고 있기 때문에 
customer 변수에 담을 수 있음 
이렇게 쓰는 이유??? -> 오버라이딩, 다형성과 연결됨

코딩 팁: 실행 파일(테스트 파일)을 먼저 만들어 보고, 이후에 필요한 클래스 파일 만들기



# 메서드 오버라이딩(overriding)
-decompile 방법 (javap -> a.out)

-묵시적 형 변환과 재정의 된 메서드 호출
Customer vc = new VIPCustomer();
vc.calcPrice(10000);

# 가상 메서드(virtual method)
위 코드에서 어느 class의 calcPrice가 호출?
-> 재정의된 메서드가 호출됨. 아니라면 상위클래스의 메서드.


-C++에서는 virtual이라는 키워드 붙여야 함
-자바는 다 virtual
-타입과 상관없이 실제 생성된 인스턴스의 메서드가 호출


함수의 코드 =명령어의 집합
변수들이 바뀌는 거고 명령어의 집합은 항상 동일 (코드는 동일)
데이터 영역 / 코드의 영역 따로 있음
함수의 명령어 집합은 항상 동일한 위치에 있다
add(5, 3)
add(10, 2)

다른곳에서 불러도 저 두 개는 같은 위치의 함수를 참조한다
코드(명렁어 셋)은 바뀔 게 없다. 항상 동일. 변수가 바뀔 뿐. 이게 코드 영역
즉, 재정의한 calcPrice 함수는 상위 클래스의 메서드와는 다른 영역에 따로 잡힌다
type이 아니라 인스턴스의 메서드가 호출된다

재정의 -> 코드 영역이 2개가 됨 -> 이때 어느 것을 부를 것이냐? instance 것을 부른다
이 가상 메서드에 의해 다형성이 구현됨

# 다형성 (polymorphism)
-상속 -> 하위 클래스가 상위 클래스의 type으로 대입이 된다 -> 하위클래스에서 상위클래스 메서드 재정의 가능
-> 가상 메서드 (인스턴스 게 불린다)

-하나의 코드가 여러 자료형으로 구현되어 실행되는 것
어떤 경우에는 이 구현, 어떤 경우에는 저 구현
코드 한 줄이 다양한 경우를 나타낼 수 있음
정보은닉, 상속과 더불어 OOP의 가장 큰 특징
OOP의 유연성, 재활용성, 유지보수성 

하나의 클래스를 상속받은 여러 클래스
각 클래스마다 같은 이름의 서로 다른 메서드 재정의
-> 상위 클래스 타입으로 선언된 하나의 변수가 여러 인스턴스에 대입되어 
다양한 구현 가능

-상속 사용?
하나의 클래스에서 여러 특성을 한꺼번에 구현하는 경우 많은 코드에 많은 if문
if(customergrade == "VIP")

else if (customergrade == "GOLD")

else if (customergrade == "SILVER")
... 이런식으로 등급 추가되면 또 생김 


# 다형성의 활용
-고객의 종류 추가
-여러 클래스 한꺼번에 어떻게 사용?
-미리 설계를 잘하면 많은 품을 들이지 않고 수정 가능

-IS-A: 일반적인 개념과 구체적인 개념. 단순히 코드 재사용 목적으로 사용하면 안됨
-HAS-A(composition, aggregation): 코드 재사용의 방법. 한 클래스가 다른 클래스를 소유한 관계. student가 subject를 포함한 관계


# downacsting 
-instanceof
-주로 오버라이딩으로 해결
-오버라이딩으로 해결이 안 되면 이걸 사용: 원래 인스턴스의 type check하여 해당하는 기능 작성.




# 추상 클래스
-추상 메서드를 포함한 클래스: 추상 메서드가 없다고 해도 추상 클래스가 될 수 있음 
-abstract
-구현 코드 없이 메서드의 선언만 있음
-new (인스턴스화) 할 수 없음
cf. concrete class

구현 메서드는 공통으로 쓰고
추상 메서드는 하위 클래스에서 각자 알아서 구현해야 하는 것 

프레임워크나 안드로이드 코딩에서 사용
framework는 어떤 것들은 틀을 이미 만들어 뒀고 그걸 상속해서 구현해야 함
listview = 전화번호, 그림 등
하위 클래스에서 각자 구현 (위임)


# 추상 클래스와 템플릿 메서드
-템플릿 메서드: 추상 메서드나 구현된 메서드를 활용해서 전체 기능의 흐름(시나리오) 정의 하는 메서드
			final로 선언하면 하위 클래스에서 재정의 불가 (시나리오를 변경할 수 없음)
			프로그램이 돌아갈 때 일련의 과정을 시나리오로 만들어 둔 메서드. 
			ex) DB 연동할 때 커넥션을 열지도 않고 쿼리를 하면 오류가 나니까
			DB 커넥션 열고 -> 연동 -> statement -> 쿼리 던지기 이런 순서(시나리오)를 정해놓은 것
			framework에서 자주 씀 

-프레임 워크에서 사용하는 설계패턴
-추상 클래스로 선언된 상위 클래스에 템플릿 메서드 활용 -> 전체적인 흐름 정의, 
하위 클래스에서 다르게 구현되어야 하는 부분은 추상 메서드로 선언 : 하위 클래스가 구현하도록 


level이 PlayerLevel이라는 상위 클래스 타입으로.
이탤릭체=추상 클래스/추상메서드

final 예약어
-final 변수는 값이 변경될 수 없는 상수임
public static final double PI = 3.14; 
-final 변수는 오직 한번만 값 할당
-final 메서드는 재정의할 수 없음 
-final class는 더 이상 상속되지 않음

동일한 메서드를 어떤 state에 따라 다양하게 구현하게 될 때 유용하다.
상속=tight한 관계.



# 인터페이스
-class처럼 선언
-메서드를 선언하는데 구현코드가 없는 메서드만
-구현 코드가 없는 메서드로 이루어진 (추상 메서드만으로 이루어진) 클래스
-어디에 쓰느냐??
-추상 클래스: 하위 클래스가 상속받아서 쓸 용도로 (일부 구현, 일부 추상)
-설계용임. 
-어떤 클래스들이 이런 메서드를 구현해야 한다 라고 정의해 둔 것 
-서버 클라이언트 관계: 
	웹 서버: 서비스를 제공하는 쪽. 인터페이스를 구현한 쪽을 서비스 모듈.
	웹 브라우저: 서비스를 갖다 쓰는 쪽. 그 인터페이스를 구현한 클래스들을 가져다 쓰는 쪽 코드가 클라이언트 코드.

CompleteCalc -> Calculator(다 구현했으면 일반 클래스인데 그러지 않다면 얘도 추상임) ->(점선)(interface) Calc


interface impelements: type 상속
class extends: 구현 상속

인터페이스를 구현한 클래스는 인터페이스형으로 선언한 변수로 형 변환 가능 = 상속에서의 형 변환
-> 하지만 type에 종속되기 때문에 사용할 수 있는 메서드는 인터페이스의 메서드뿐
구현 코드가 없기 때문에 여러 인터페이스 구현 가능 
C++에서는 여러 class 상속이 가능한데 java에서는 그렇게 하면 모호함이 발생 (diamond problem)
extends 뒤에는 1개
implements 뒤에는 여러 개 (쉼표로 구분)

# 인터페이스와 다형성
-인터페이스: 클라이언트 코드-서비스를 제공하는 객체 사이의 약속
-어떤 객체가 어떤 interface type =그 interface가 제공하는 메서드를 구현했다는 의미
-클라이언트: 어떻게 구현되었는지 상관없이 interface의 정의만을 보고 사용할 수 있음
ex) JDBC
- 다양한 구현이 필요한 인터페이스를 설계하는 일은 매우 중요한 것

구현: 여러 다양한 구현이 동일한 메서드를 제공할 수도 있음
다양한 구현에 대해 사용하는 쪽에서 일일이 알 필요는 없음. 어떻게 쓰면 된다 <를 알면 됨
이 어떻게 쓰면 된다를 알려주는 게 인터페이스가 하는 역할. 


# 인터페이스의 요소
-모든 변수는 상수로 변환됨
-모든 메서드는 구현 없는 추상 메서드로

*java 8부터 추가된 내용. 기존에는 추상 메서드밖에 선언 못 했음.
new 될 수 있는 건 아님!!!
-디폴트 메서드: 기본 구현을 가지는 메서드. 구현 클래스에서 재정의
재정의 안 하면 이 코드가 그대로 감.

-정적 메서드: 인스턴스 생성과 상관없이 인터페이스 타입으로 사용
new 불가. 그런데 어떤 클래스가 인터페이스를 구현하지 않았는데도 쓰고 싶다.

-private 메서드: 재정의 불가. 인터페이스 내부에서만 기능 제공을 위해 구현.
구현하는 클래스에서 사용할 수 없고 재정의할 수 없음. 
-class extends & implements interface 같이 쓰는 방법

하나의 인터페이스는 여러 클래스로 구현될 수 있음.

클래스: 구현되어 있음. 다중상속 불가.
인터페이스: 구현 코드 없음. 여러 개 implement 가능
디폴트 메서드 중복되면 걍 재정의해서 사용

# 인터페이스 상속
-인터페이스간에도 상속 가능
-형 상속 (type inheritance)

X, Y도 인터페이스일 때 
public interface MyInterface extends X, Y


# 인터페이스 구현과 클래스 상속 함께 사용
public class BookShelf extends Shelf implements Queue

extends 먼저 
클래스를 상속받고, 여러 인터페이스를 구현

-프레임워크: 구멍을 메꾸는 코딩 방법
-로직의 순서는 정해져 있음 (어떻게 호출될지 정해져 있음)
ㄴ 빈칸을 메꿔서 이 프레임워크가 내가 원하는 대로 돌아가게 하는 것

Queue; 선착순 자료구조 





